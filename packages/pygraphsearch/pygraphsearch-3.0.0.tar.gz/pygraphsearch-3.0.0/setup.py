# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pygraphsearch', 'pygraphsearch.frontiers']

package_data = \
{'': ['*']}

install_requires = \
['typed-data-structures>=0.0.2,<0.0.3']

setup_kwargs = {
    'name': 'pygraphsearch',
    'version': '3.0.0',
    'description': 'A python package to search graphs.',
    'long_description': '# pygraphsearch\n\nA python package to search graphs.\n\n---\n\n## 1. Installation\n\nTo install the package, run the following command.\n\n```\npip install pygraphsearch\n```\n\n## 2. Usage\n\nAs an example on how to use this package, we will make a program that will solve sliding puzzles. The complete source code is in the folder [example](example). We will provide the program with some shuffled arrangement of tiles as the starting node, and we will tell it what the correct tile arrangement is as the target node.\n\nWe will also tell it how to move from one board to another.\n\n### 2.1 Node\n\nThis package includes a Node class which your nodes should inherit from. In our example, we will make a class `Board` that extends `Node`. This class will represent the layout of the tiles on the board at any given time.\n\nTo override `Node` we must override the function `neighbours`. This function should return edges to all the nodes reachable from the current node.\n\nIn a sliding puzzle, there are always up to four legal moves. The empty tile can move up, down, left, or right, unless it\'s on an edge of the board in which case it can\'t move past the edge. We can make an enum called [Move](example/Move.py) to store these four options.\n\nTo check if a move is legal, we can create a method `can_move`. If we are able to move in a direction, then we call the board\'s `move` method which will return a copy of the board but with the given move applied.\n\nThe important thing here is that we define the function `neighbours` which returns some edges.\n\n**Note**: Your node objects must also implement `__hash__` and `__eq__`.\n\n```py\nfrom pygraphsearch import Node, Edge\nfrom typing import Iterable # it\'s always good to specify types\nfrom .Move import Move\n\nclass Board(Node):\n\n\t# ...\n\n\tdef neighbours(self) -> Iterable[Edge]:\n\t\treturn [\n\t\t\tEdge(self, self.move(move), move)\n\t\t\tfor move in Move\n\t\t\tif self.can_move(move)\n\t\t]\n\n\tdef __eq__(self, board: object) -> bool:\n\t\treturn isinstance(board, Board) and self.__tiles == board.__tiles\n\n\tdef __hash__(self) -> int:\n\t\treturn hash(tuple(self.__tiles))\n```\n\n### 2.2 Edges\n\nAs we saw in the previous section, the `neighbours` method has to return an `Edge`. This class is defined in this package and can be constructed by passing it two nodes and some optional data. The data, if passed, is used to convert an edge into a string for convenience, but otherwise not used by the search package.\n\nIn our example it will be useful to store the direction that the empty tile is moved in an edge, as it will allow us to reconstruct the solution later.\n\n### 2.3 Basic Usage\n\nNow that we have our nodes, we will write a basic program that will request a puzzle from the user and attempt to solve it using the `search` function provided by this package.\n\nTo get the puzzle size and initial board layout, we\'ll make the following function.\n\n```py\ndef get_board_details() -> Tuple[int, List[int]]:\n\t# get board size\n\tsize = int(\n\t\tinput("Enter the size of the sliding puzzle. (e.g. for a 3x3 puzzle enter 3): ")\n\t)\n\tprint(\n\t\tf"Enter {size * size} tile values row by row from top left to bottom right."\n\t\t" (Use 0 for the empty tile)"\n\t)\n\t# get list of size * size integer inputs from user\n\ttiles = [int(input()) for _ in range(size * size)]\n\n\treturn size, tiles\n```\n\nThen we\'ll use the following code to perform the search.\n\n```py\n# Get board details from the user\nsize, tiles = get_board_details()\n\n# Construct the initial node\nstart_board = Board(size, tiles)\n\n# Construct the target node, eg a board with the tiles in order: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = Board(size, range(size * size))\n\n# Create a frontier with custom parameters\nfrontier = IterativeDeepeningFrontier(start_board, initial_depth=2, depth_step=2)\n\n# Call the search function with our frontier and with a lambda to tell it that a node is a target if it is equal to `target`\nstate1 = search(frontier, lambda node: node == target)\n\n# Or simply call the function with the default options for one of the predefined algorithms\nstate2 = search(\n\tstart_board, lambda node: node == target, Algorithm.BREADTH_FIRST_SEARCH # (DFS would take forever for this problem)\n)\n```\n\nAs you can see, there are two ways to call the search function. The simplest way is to provide it with:\n\n-   a start node,\n-   a function which takes a node and returns true if the node is a target node or false otherwise, and\n-   which algorithm to use.\n\nThe other way to call the search function is to provide it with:\n\n-   a frontier (more on that in the next section) and\n-   a function which takes a node and returns true if the node is a target node or false otherwise.\n\n### 2.4 Frontiers\n\nA frontier is the heart of the search algorithm. It is a data structure which holds the furthest nodes we have explored and it determines the order in which we will explore them further.\n\nFor BFS, the frontier would be a FIFO queue. For DFS, it would be a LIFO stack.\n\nIf you want to implement your own search algorithms, all you need is to implement a frontier to pass to the `search` function by extending the abstract `Frontier` class provided by this package and implementing the abstract methods. These are:\n\n-   `insert(self, state: State)` to insert states into the stack,\n-   `extract(self) -> Optional[State]` to extract states from the stack, and\n-   `__len__(self) -> int` which is the number of states stored in the frontier. The only important thing to be aware of about this function is that it should return 0 only when there are no more states to extract. If for some reason you can\'t or don\'t want to conform to this, you\'ll have to override `is_empty` to return true only when there are no more states to extract, and the search is done.\n\n### 2.5 State\n\nThe search function returns a state object. This object has two properties.\n\n-   `node (Node)`: The target node. In our example this would be the state of the solved board.\n-   `path (List[Edge])`: A list of the edges that lead from the start to the target node.\n\nUsing these, we can print the moves to solve the puzzle to the user, like so (continuing from the previous code):\n\n```py\nif state1 is not None:\n\tfor edge in state1.path:\n\t\tprint(edge.data, end=" ")\n```\n\nHere we\'re using edge.data which we set before by passing the moves to the `Edge` constructor in the `Board` class. By accessing the edges\' data, we can retrieve the moves that were taken by the search algorithm to reach the solved state and print it back to the user.\n',
    'author': 'Abraham Murciano',
    'author_email': 'abrahammurciano@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/abrahammurciano/pygraphsearch',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
