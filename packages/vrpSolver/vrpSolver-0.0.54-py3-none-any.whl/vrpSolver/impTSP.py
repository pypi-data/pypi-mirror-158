import heapq

from .common import *

def impTSP(
	nodes:		"Dictionary, returns the coordinate of given nodeID, \
					{\
						nodeID1: {'loc': (x, y)}, \
						nodeID2: {'loc': (x, y)}, \
						... \
					}" = None, 
	edges:		"1) String (default) 'Euclidean' or \
				 2) String 'SphereEuclidean' or \
				 3) Dictionary {(nodeID1, nodeID2): dist, ...}" = "Euclidean",
	initSeq:	"Sequence of visiting nodes, as the initial route, generated by constructive heuristic" = [],
	algo:		"1) String (not available) 'LKH' or \
				 2) String (default) '2Opt' = '2Opt'" = '2Opt'
	) -> "Local improvement heuristic solution for TSP":

	# Define edges ============================================================
	if (type(edges) is not dict):
		if (edges == 'Euclidean'):
			edges = getTauEuclidean(nodes)
		elif (edges == 'SphereEuclidean'):
			edges = getTauSphereEuclidean(nodes)
		else:
			print("Error: Incorrect type `edges`")
			return None

	# Heuristics that don't need to transform arc representation ==============
	res = None
	nodeIDs = list(nodes.keys())
	if (algo == '2Opt'):
		res = _impTSP2Opt(nodeIDs, edges, initSeq)
	return res

def _impTSP2Opt(nodeIDs, edges, initSeq):
	# Initialize ==============================================================
	canImproveFlag = True
	impSeq = [i for i in initSeq]

	# Revert part of the sequences ============================================
	def revert(i, j, seq):
		rSeq = []

		rSeq.extend([seq[k] for k in range(i)])
		rSeq.extend([seq[j - k] for k in range(j - i + 1)])
		rSeq.extend([seq[k] for k in range(j + 1, len(seq))])

		return rSeq

	# Main iteration ==========================================================
	while (canImproveFlag):
		canImproveFlag = False

		# Try 2-opt -----------------------------------------------------------
		# First arc: (i, i + 1)
		# Second arc: (j, j + 1)
		# New arcs: (i, j + 1), (j, i + 1)
		bestSaving = 0
		bestMove = None
		for i in range(len(impSeq) - 3):
			for j in range(i + 2, len(impSeq) - 1):
				# Saving
				saving = 0
				if ((impSeq[i], impSeq[j]) in edges and (impSeq[i + 1], impSeq[j + 1]) in edges):
					saving = (edges[impSeq[i], impSeq[i + 1]] + edges[impSeq[j], impSeq[j + 1]]) - (edges[impSeq[i], impSeq[j]] + edges[impSeq[i + 1], impSeq[j + 1]])
				if (saving > bestSaving):
					bestSaving = saving
					bestMove = (i, j)

		if (bestSaving > 0):
			(i, j) = bestMove
			impSeq = revert(i + 1, j, impSeq)
			canImproveFlag = True

	# Calculate ofv ===========================================================
	ofv = calSeqCostMatrix(edges, impSeq)

	return {
		'ofv': ofv,
		'seq': impSeq
	}