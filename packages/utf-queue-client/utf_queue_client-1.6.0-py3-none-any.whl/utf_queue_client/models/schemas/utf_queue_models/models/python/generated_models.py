# generated by datamodel-codegen:
#   filename:  queue_message.json
#   timestamp: 2022-07-11T10:19:02+00:00

from typing import Any, Optional, Union

from pydantic import Extra, Field
from typing_extensions import Literal
from utf_queue_client.models.base_model import BaseModelWithValidation


class Model(BaseModelWithValidation):
    __root__: Any


class QueueRecord(BaseModelWithValidation):
    pass

    class Config:
        extra = Extra.allow


class TelemetryData(BaseModelWithValidation):
    dataType: Literal['LOGS', 'METRICS', 'TRACES']
    base64ProtobufData: str
    compression: Optional[str] = None


class ArtifactMetadata(BaseModelWithValidation):
    pass

    class Config:
        extra = Extra.allow


class ArtifactBuildMetadata(BaseModelWithValidation):
    branch: Optional[str] = None
    stack: Optional[str] = None
    build_number: Optional[str] = None
    target: Optional[str] = None
    studio: Optional[str] = None
    compiler: Optional[str] = None
    app_name: Optional[str] = None
    test_suite: Optional[str] = None
    chip_id: Optional[str] = None
    studio_build_version: Optional[str] = None
    compiler_build_version: Optional[str] = None


class SqaAppBuildResult(BaseModelWithValidation):
    releaseName: str = Field(
        ..., description='Need table for validation created from the existing java enum'
    )
    stackName: str = Field(
        ..., description='Need table for validation created from the existing java enum'
    )
    buildNum: int = Field(..., description='Comes from Jenkins')
    suiteName: Optional[str] = Field(
        None, description='Description of the grouping of applications'
    )
    branchName: str = Field(..., description='GSDK Branch Name')
    appDescription: Optional[str] = Field(
        None, description='Description of what the application does'
    )
    resultType: Literal[
        'BUILDAPP', 'DBTEST', 'FEATURE', 'OTHER', 'REGRESSION', 'SMOKE'
    ] = Field(
        ..., description='Need table for validation created from the existing java enum'
    )
    appName: str = Field(..., description='Name of the application')
    testExecutorName: str = Field(..., description='Where the application was built')
    moduleName: str = Field(
        ..., description='Description of the device type that the application runs on'
    )
    testResult: Literal['blocked', 'failed', 'passed', 'skipped'] = Field(
        ..., description='Did the application build'
    )
    exceptionMsg: Optional[str] = Field(
        None, description='Stack dump exception message from build'
    )
    iotReqId: str = Field(..., description='JIRA IOT Req Number')
    toolChain: str = Field(
        ...,
        description='Need table for validation.\nThis is the tool and version used to build the application with colon separation\niar:7.80.1',
    )
    runNum: int = Field(..., description='Jenkins run number')
    studioBuildNum: Optional[int] = Field(
        None, description='Version of studio used to build the application'
    )
    studioUrl: Optional[str] = Field(
        None,
        description='URL where studio was downloaded from\ni.e. Jenkins, Nexus, etc.',
    )
    buildDurationSec: int = Field(
        ...,
        description='Length of time to build the application\nGoes to the column testDuration',
    )


class SqaTestResult(BaseModelWithValidation):
    sessionPkId: str = Field(
        ...,
        description='Logical FK to dbo.jobStatusTable.\nNot creating the constraint in case this comes in before the session record.',
    )
    testCaseId: str = Field(
        ...,
        description='Passed in from the test executor.\nFrom the test management system or git.',
    )
    testSuiteName: Optional[str] = Field(None, description='Named group of tests')
    testDescription: Optional[str] = Field(
        None, description='What does the test case actually do'
    )
    testResultType: Literal[
        'buildapp',
        'compliance',
        'dbtest',
        'duration',
        'endurance',
        'feature',
        'na',
        'negative',
        'performance',
        'regression',
        'repeatability',
        'smoke',
        'soak',
        'system',
        'test',
    ] = Field(..., description='Need to create a table for verification of this field')
    testCaseName: str = Field(
        ...,
        description='Human readable version of the test case ID\nShort summary/description',
    )
    testExecutorName: str = Field(..., description='Where the test actually ran')
    featureName: str = Field(..., description='Feature being tested by this test')
    testCreationDate: str = Field(
        ..., description='Date the test was created\nISO-8601 format'
    )
    testbedName: str = Field(
        ..., description='Grouping of all of the hardware used to execute the test'
    )
    moduleName: str = Field(..., description='Testbed component list')
    phyName: Optional[str] = Field(
        None, description='Radio configuration used by the device'
    )
    testResult: Literal['block', 'fail', 'pass', 'skip']
    testParametricData: Optional[str] = Field(None, description='Test Parametric Data')
    engineerName: Optional[str] = Field(
        None, description='Name of the engineer who created the test'
    )
    exceptionMsg: Optional[str] = Field(
        None, description='If an error occurs, this is the message returned.'
    )
    iotReqId: str
    toolChain: str = Field(
        ...,
        description='Need table for validation.\nThis is the tool and version used to build the application with colon separation\niar:7.80.1',
    )
    vendorName: Optional[str] = None
    vendorBuild: Optional[str] = None
    vendorResult: Optional[str] = None
    notes: Optional[str] = None
    portalWatch: Optional[str] = Field(
        None, description='Change this to boolean - default false'
    )
    testDurationSec: float = Field(..., description='Test duration in seconds')
    testCaseVersionNum: Optional[int] = None


class SqaTestSession(BaseModelWithValidation):
    sessionPkId: str = Field(
        ..., description='UUID generated by the Jenkins client software'
    )
    sessionStartTime: str = Field(..., description='ISO-8601 Datetime')
    sessionStopTime: Optional[str] = Field(None, description='ISO-8601 datetime')
    jenkinsJobStatus: Literal['COMPLETE', 'FAIL', 'IN PROGRESS'] = Field(
        ..., description='Status of the Jenkins job'
    )
    sessionDurationSec: Optional[int] = Field(
        None,
        description='Elapsed number of seconds for the Jenkins job.\nShould be close to stop time - start time.\nChange the data type in the DB to integer.',
    )
    jobType: Optional[
        Literal[
            'buildapp',
            'compliance',
            'dbtest',
            'duration',
            'endurance',
            'feature',
            'na',
            'negative',
            'performance',
            'regression',
            'repeatability',
            'smoke',
            'soak',
            'system',
            'test',
        ]
    ] = Field(None, description='Type of Jenkins job')
    releaseName: str
    branchName: str
    stackName: str
    sdkBuildNum: int
    sdkUrl: Optional[str] = None
    studioUrl: Optional[str] = None
    totalTestCount: Optional[int] = None
    passCount: Optional[int] = None
    failCount: Optional[int] = None
    skipCount: Optional[int] = None
    jenkinsServerName: str
    jenkinsRunNum: int
    jenkinsJobName: str
    jenkinsTestResultsUrl: str


class LogEvent(BaseModelWithValidation):
    pass


class ExceptionEvent(BaseModelWithValidation):
    pass


class QueueMessage(BaseModelWithValidation):
    recordType: Literal[
        'ARTIFACT_UPLOAD_REQUEST',
        'EXCEPTION_EVENT',
        'LOG_EVENT',
        'OPENTELEMETRY_DATA',
        'UTF_TEST_EVENT',
    ] = Field(..., description='Type of record')
    recordSubType: Optional[
        Literal['BUILD_RESULT', 'SESSION_START', 'SESSION_STOP', 'TEST_RESULT']
    ] = Field(
        None,
        description='Subtype of record. Not all types have a subtype, but it is required when they have one.',
    )
    tenantKey: str = Field(
        ...,
        description='Unique string that identifies the app/group sending the message.\nForward looking to match the data lake infrastructure.',
    )
    recordTimestamp: str = Field(
        ...,
        description='UTC datetime.\nUse ISO-8601 format with time zone\n2022-03-10T18:50:05Z',
    )
    payload: 'QueueRecord' = Field(
        ...,
        description='Record Payload.\nThis is flexible to allow different fields for different record types and DB tables',
    )


class QueueMessageV1(BaseModelWithValidation):
    recordType: Literal[
        'ARTIFACT_UPLOAD_REQUEST',
        'EXCEPTION_EVENT',
        'LOG_EVENT',
        'TEST_EVENT',
        'UTF_TEST_EVENT',
    ] = Field(..., description='Type of record')
    payload: 'QueueRecord' = Field(..., description='Record Payload')
    timestamp: float = Field(
        ..., description='UTC Timestamp\nGiven in seconds since epoch (unix time)'
    )


class ArtifactUploadRequest(BaseModelWithValidation):
    name: str
    extension: str
    metadata: Union['ArtifactMetadata', 'ArtifactBuildMetadata']
    base64Content: str
    validateMetadata: bool
