<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: src/proshade/ProSHADE_symmetry.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.6.6 (JUL 2022)</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_pro_s_h_a_d_e__symmetry_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_symmetry.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header file declares all the functions required for symmetry detection and construction.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_pro_s_h_a_d_e__distances_8hpp_source.html">ProSHADE_distances.hpp</a>&quot;</code><br />
</div>
<p><a href="_pro_s_h_a_d_e__symmetry_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_pro_s_h_a_d_e__internal__symmetry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html">ProSHADE_internal_symmetry</a></td></tr>
<tr class="memdesc:namespace_pro_s_h_a_d_e__internal__symmetry"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains the symmetry detection related code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad977c265833d6466598cceb406a085db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">ProSHADE_internal_symmetry::isSymmetrySame</a> (std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres, proshade_signed *matchedPos)</td></tr>
<tr class="memdesc:ad977c265833d6466598cceb406a085db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a very similar symmetry is not already saved.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad977c265833d6466598cceb406a085db">More...</a><br /></td></tr>
<tr class="separator:ad977c265833d6466598cceb406a085db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af3702dc9022c3afcaf72b049779f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a10af3702dc9022c3afcaf72b049779f3">ProSHADE_internal_symmetry::isSymmetrySame</a> (std::vector&lt; proshade_double * &gt; *ret, proshade_double *sym, proshade_double simThres, proshade_signed *matchedPos, proshade_double fscVal)</td></tr>
<tr class="memdesc:a10af3702dc9022c3afcaf72b049779f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a very similar symmetry is not already saved.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a10af3702dc9022c3afcaf72b049779f3">More...</a><br /></td></tr>
<tr class="separator:a10af3702dc9022c3afcaf72b049779f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37925ac477480c718451debb01a9c74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">ProSHADE_internal_symmetry::detectTetrahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a37925ac477480c718451debb01a9c74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for tetrahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a37925ac477480c718451debb01a9c74a">More...</a><br /></td></tr>
<tr class="separator:a37925ac477480c718451debb01a9c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5d4e5e34da6e4a9ed4a67cca16491c17">ProSHADE_internal_symmetry::findTetra4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 4 C3 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5d4e5e34da6e4a9ed4a67cca16491c17">More...</a><br /></td></tr>
<tr class="separator:a5d4e5e34da6e4a9ed4a67cca16491c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">ProSHADE_internal_symmetry::testGroupAgainstSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, proshade_double *sym, proshade_double axErr, proshade_double angle, bool improve, proshade_unsign pos=0)</td></tr>
<tr class="memdesc:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a symmetry has particular angle to all members of a group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad8c193e95c7069fafa78dccc1de1aaa4">More...</a><br /></td></tr>
<tr class="separator:ad8c193e95c7069fafa78dccc1de1aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6093da290ce7b73a33e8b55f2c83491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">ProSHADE_internal_symmetry::findMissingAxes</a> (std::vector&lt; std::vector&lt; proshade_unsign &gt; &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_double angle, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:af6093da290ce7b73a33e8b55f2c83491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find an axis which would complete a particular group of axes for polyhedral symmetry detection.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af6093da290ce7b73a33e8b55f2c83491">More...</a><br /></td></tr>
<tr class="separator:af6093da290ce7b73a33e8b55f2c83491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">ProSHADE_internal_symmetry::missingAxisHeight</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:ad44ed609e8a3d59674b2b2256aec41f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for the highest peaks average that would produce the required axis and fold.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ad44ed609e8a3d59674b2b2256aec41f8">More...</a><br /></td></tr>
<tr class="separator:ad44ed609e8a3d59674b2b2256aec41f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465606e58df7d6a2238d40c6919b2e58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">ProSHADE_internal_symmetry::findMissingAxisPoints</a> (proshade_double xVal, proshade_double yVal, proshade_double zVal, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_double axErr)</td></tr>
<tr class="memdesc:a465606e58df7d6a2238d40c6919b2e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for all the self-rotation map points conforming to the axis, returning their angles and heights.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a465606e58df7d6a2238d40c6919b2e58">More...</a><br /></td></tr>
<tr class="separator:a465606e58df7d6a2238d40c6919b2e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">ProSHADE_internal_symmetry::sortArrVecHlp</a> (const proshade_double *a, const proshade_double *b)</td></tr>
<tr class="memdesc:a68d576f90449b7d3fcf5ae4d3114c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two arrays of two based on the first number.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a68d576f90449b7d3fcf5ae4d3114c268">More...</a><br /></td></tr>
<tr class="separator:a68d576f90449b7d3fcf5ae4d3114c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc4353223fc752e0007b2adec193079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">ProSHADE_internal_symmetry::saveMissingAxisNewOnly</a> (std::vector&lt; proshade_double * &gt; *axVec, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double height, proshade_unsign fold, proshade_double axErr)</td></tr>
<tr class="memdesc:a5dc4353223fc752e0007b2adec193079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves the recovered information about missing axis into a full symmetry, making sure no duplicates are created.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5dc4353223fc752e0007b2adec193079">More...</a><br /></td></tr>
<tr class="separator:a5dc4353223fc752e0007b2adec193079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada2416687dbb0bec93603770cb4c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">ProSHADE_internal_symmetry::searchMissingSymmetrySpace</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp, std::vector&lt; proshade_double * &gt; *hlpVec, proshade_double axErr, proshade_double angle, proshade_unsign fold, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a1ada2416687dbb0bec93603770cb4c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests feasible axes against the missing axis criteria, returning a set of matching axes.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1ada2416687dbb0bec93603770cb4c83">More...</a><br /></td></tr>
<tr class="separator:a1ada2416687dbb0bec93603770cb4c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5e5d3ccec33e4cf7204124a5647fe5c9">ProSHADE_internal_symmetry::findTetra3C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C2 symmetries with correct angles required for full tetrahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5e5d3ccec33e4cf7204124a5647fe5c9">More...</a><br /></td></tr>
<tr class="separator:a5e5d3ccec33e4cf7204124a5647fe5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360c152697780177eb2676888cd5108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">ProSHADE_internal_symmetry::testGroupAgainstGroup</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_unsign &gt; *grp1, std::vector&lt; proshade_double * &gt; *RetList, std::vector&lt; proshade_unsign &gt; *grp2, proshade_double angle, proshade_double axErr)</td></tr>
<tr class="memdesc:a5360c152697780177eb2676888cd5108"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two groups of axes for a single pair having the required angle.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a5360c152697780177eb2676888cd5108">More...</a><br /></td></tr>
<tr class="separator:a5360c152697780177eb2676888cd5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d456057604616a7cf6b68f59b4f2d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">ProSHADE_internal_symmetry::detectOctahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a18d456057604616a7cf6b68f59b4f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for octahhedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a18d456057604616a7cf6b68f59b4f2d0">More...</a><br /></td></tr>
<tr class="separator:a18d456057604616a7cf6b68f59b4f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a31e25079d4a20a0d6442c7fb36fdeaea">ProSHADE_internal_symmetry::findOcta3C4s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the 3 C4 symmetries with perpendicular angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a31e25079d4a20a0d6442c7fb36fdeaea">More...</a><br /></td></tr>
<tr class="separator:a31e25079d4a20a0d6442c7fb36fdeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db775b80f6ce426bb98d87f8ba99d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1db775b80f6ce426bb98d87f8ba99d72">ProSHADE_internal_symmetry::findOcta4C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a1db775b80f6ce426bb98d87f8ba99d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the four C3 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a1db775b80f6ce426bb98d87f8ba99d72">More...</a><br /></td></tr>
<tr class="separator:a1db775b80f6ce426bb98d87f8ba99d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f24f5b37a7810ce379fce1b71877a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a7f24f5b37a7810ce379fce1b71877a0e">ProSHADE_internal_symmetry::findOcta6C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a7f24f5b37a7810ce379fce1b71877a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C2 symmetries with correct angles required for full octahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a7f24f5b37a7810ce379fce1b71877a0e">More...</a><br /></td></tr>
<tr class="separator:a7f24f5b37a7810ce379fce1b71877a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">ProSHADE_internal_symmetry::findMissingAxesDual</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axes which would complete a group of symmetries with two different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a6d9f533a789bd5c6031fa77b9649ed3d">More...</a><br /></td></tr>
<tr class="separator:a6d9f533a789bd5c6031fa77b9649ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a784fd675e871b3b032d8f62013262"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a00a784fd675e871b3b032d8f62013262">ProSHADE_internal_symmetry::addAxisUnlessSame</a> (proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</td></tr>
<tr class="memdesc:a00a784fd675e871b3b032d8f62013262"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a00a784fd675e871b3b032d8f62013262">More...</a><br /></td></tr>
<tr class="separator:a00a784fd675e871b3b032d8f62013262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">ProSHADE_internal_symmetry::addAxisUnlessSame</a> (proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axHeight, proshade_double averageFSC, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr)</td></tr>
<tr class="memdesc:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply creates a new axis from information in aruments and tests if no such axis already exists, saving it if need be.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a262d9e21cd6b81b8bda35ec22eb363dd">More...</a><br /></td></tr>
<tr class="separator:a262d9e21cd6b81b8bda35ec22eb363dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ee0af651d440b68168882ead71c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">ProSHADE_internal_symmetry::checkFittingAxisDualAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a210ee0af651d440b68168882ead71c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a210ee0af651d440b68168882ead71c66">More...</a><br /></td></tr>
<tr class="separator:a210ee0af651d440b68168882ead71c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09b90de1f15b345ee7998ff31327f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">ProSHADE_internal_symmetry::detectIcosahedralSymmetry</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a4f09b90de1f15b345ee7998ff31327f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and decides whether basic requirements for isosahedral symmetry are there.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4f09b90de1f15b345ee7998ff31327f3">More...</a><br /></td></tr>
<tr class="separator:a4f09b90de1f15b345ee7998ff31327f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dec365c5650c93198d73b6d259e4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4dec365c5650c93198d73b6d259e4e7">ProSHADE_internal_symmetry::findIcos6C5s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:af4dec365c5650c93198d73b6d259e4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the six C5 symmetries with given angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#af4dec365c5650c93198d73b6d259e4e7">More...</a><br /></td></tr>
<tr class="separator:af4dec365c5650c93198d73b6d259e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53cd7561731d9426989f5ace523826a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab53cd7561731d9426989f5ace523826a">ProSHADE_internal_symmetry::findIcos10C3s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:ab53cd7561731d9426989f5ace523826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the ten C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ab53cd7561731d9426989f5ace523826a">More...</a><br /></td></tr>
<tr class="separator:ab53cd7561731d9426989f5ace523826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422414bb07db89a5c797f371a5448c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a422414bb07db89a5c797f371a5448c0e">ProSHADE_internal_symmetry::findIcos15C2s</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, proshade_double axErr, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, proshade_signed verbose, proshade_signed messageShift, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a422414bb07db89a5c797f371a5448c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the list of C symmetries and finds the fifteen C3 symmetries with correct angles required for full icosahedral symmetry.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a422414bb07db89a5c797f371a5448c0e">More...</a><br /></td></tr>
<tr class="separator:a422414bb07db89a5c797f371a5448c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae266053664eb7cf916aa5e2d282e35dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">ProSHADE_internal_symmetry::findMissingAxesTriple</a> (std::vector&lt; proshade_unsign &gt; *possibilities, std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; proshade_double * &gt; *ret, std::vector&lt; proshade_unsign &gt; *retGroup, proshade_unsign requiredNoAxes, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, proshade_unsign fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:ae266053664eb7cf916aa5e2d282e35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to find a particular symmetry axis which would complete a group of symmetries with three different angle requirement to another group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae266053664eb7cf916aa5e2d282e35dd">More...</a><br /></td></tr>
<tr class="separator:ae266053664eb7cf916aa5e2d282e35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194944b48a4b6b523ef251a2a03eab17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">ProSHADE_internal_symmetry::checkFittingAxisTripleAndSave</a> (std::vector&lt; proshade_unsign &gt; *retGroup, std::vector&lt; proshade_double * &gt; *ret, proshade_unsign fold, proshade_double axX, proshade_double axY, proshade_double axZ, std::vector&lt; proshade_double * &gt; *prosp, proshade_double axErr, proshade_unsign noMatchesG1, proshade_double angle1, proshade_unsign noMatchesG2, proshade_double angle2, proshade_unsign noMatchesG3, proshade_double angle3, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj)</td></tr>
<tr class="memdesc:a194944b48a4b6b523ef251a2a03eab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a newly detected "missing" axis and tests it for belonging to the group, checking the height and replacing lower height members with better members.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194944b48a4b6b523ef251a2a03eab17">More...</a><br /></td></tr>
<tr class="separator:a194944b48a4b6b523ef251a2a03eab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c00659b5f6abf315fb5a426c45810c"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a58c00659b5f6abf315fb5a426c45810c">ProSHADE_internal_symmetry::findPredictedSingleAxisHeight</a> (proshade_double *axis, proshade_double fold, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a58c00659b5f6abf315fb5a426c45810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the rotation function value for a single axis.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a58c00659b5f6abf315fb5a426c45810c">More...</a><br /></td></tr>
<tr class="separator:a58c00659b5f6abf315fb5a426c45810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c650c19a6954800bba6b3a8f5842e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">ProSHADE_internal_symmetry::findPredictedAxesHeights</a> (std::vector&lt; proshade_double * &gt; *ret, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a33c650c19a6954800bba6b3a8f5842e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the rotation function value for all axes supplied in the ret parameter.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a33c650c19a6954800bba6b3a8f5842e6">More...</a><br /></td></tr>
<tr class="separator:a33c650c19a6954800bba6b3a8f5842e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39de1c901703986cb476d8cb8cf9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">ProSHADE_internal_symmetry::optimiseDGroupAngleFromAxesHeights</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *ret, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:a8b39de1c901703986cb476d8cb8cf9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a8b39de1c901703986cb476d8cb8cf9dc">More...</a><br /></td></tr>
<tr class="separator:a8b39de1c901703986cb476d8cb8cf9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9966655e7cfbf988ef38d4653bd69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae4e9966655e7cfbf988ef38d4653bd69">ProSHADE_internal_symmetry::optimiseDGroupAngleFromAxesHeights</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *allCs, std::vector&lt; proshade_unsign &gt; selection, <a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *dataObj, <a class="el" href="class_pro_s_h_a_d_e__settings.html">ProSHADE_settings</a> *settings)</td></tr>
<tr class="memdesc:ae4e9966655e7cfbf988ef38d4653bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two axes with almost dihedral angle and optimises their relative positions as well as orientation with respect to the optimal angle and the rotation function.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#ae4e9966655e7cfbf988ef38d4653bd69">More...</a><br /></td></tr>
<tr class="separator:ae4e9966655e7cfbf988ef38d4653bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a16d3cf24f73eafc1d5b8ef9e204aaf8d">ProSHADE_internal_symmetry::predictIcosAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all possible icosahedral point groups symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a16d3cf24f73eafc1d5b8ef9e204aaf8d">More...</a><br /></td></tr>
<tr class="separator:a16d3cf24f73eafc1d5b8ef9e204aaf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725c087c9e21544b956b5effa600786e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a725c087c9e21544b956b5effa600786e">ProSHADE_internal_symmetry::predictOctaAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:a725c087c9e21544b956b5effa600786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all octahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a725c087c9e21544b956b5effa600786e">More...</a><br /></td></tr>
<tr class="separator:a725c087c9e21544b956b5effa600786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd7f6ed25c6a8ae4e2f151a6c217d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#adbd7f6ed25c6a8ae4e2f151a6c217d0a">ProSHADE_internal_symmetry::predictTetraAxes</a> (std::vector&lt; proshade_double * &gt; *CSymList, std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *ret, proshade_double axErr, proshade_double minPeakHeight)</td></tr>
<tr class="memdesc:adbd7f6ed25c6a8ae4e2f151a6c217d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts all tetrahedral point group symmetry axes from the cyclic point groups list.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#adbd7f6ed25c6a8ae4e2f151a6c217d0a">More...</a><br /></td></tr>
<tr class="separator:adbd7f6ed25c6a8ae4e2f151a6c217d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61445eea893c993648011b3037d2e9ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_unsign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a61445eea893c993648011b3037d2e9ed">ProSHADE_internal_symmetry::findReliableUnphasedSymmetries</a> (std::vector&lt; proshade_double * &gt; *allCs, std::vector&lt; std::vector&lt; proshade_double * &gt; &gt; *allDs, proshade_signed verbose, proshade_signed messageShift, proshade_double tolerance)</td></tr>
<tr class="memdesc:a61445eea893c993648011b3037d2e9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the list of detected axes (presumably from phaseless symmetry detection) and returns the best dihedral (or cyclic, if no dihedral is found) point group, or empty vector if nothing is found.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a61445eea893c993648011b3037d2e9ed">More...</a><br /></td></tr>
<tr class="separator:a61445eea893c993648011b3037d2e9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952318f67deb547d73ae3ed62ee6d5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a952318f67deb547d73ae3ed62ee6d5c4">ProSHADE_internal_symmetry::allocateCentreOfMapFourierTransforms</a> (proshade_unsign xDim, proshade_unsign yDim, proshade_unsign zDim, fftw_complex *&amp;origMap, fftw_complex *&amp;origCoeffs, fftw_complex *&amp;rotMapComplex, fftw_complex *&amp;rotCoeffs, fftw_complex *&amp;trFunc, fftw_complex *&amp;trFuncCoeffs, fftw_plan *planForwardFourier, fftw_plan *planForwardFourierRot, fftw_plan *planReverseFourierComb)</td></tr>
<tr class="memdesc:a952318f67deb547d73ae3ed62ee6d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the required memory for the Fourier transforms required to find the centre of the map.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a952318f67deb547d73ae3ed62ee6d5c4">More...</a><br /></td></tr>
<tr class="separator:a952318f67deb547d73ae3ed62ee6d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67dc983f98cde3963b0d805f41ce30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4e67dc983f98cde3963b0d805f41ce30">ProSHADE_internal_symmetry::releaseCentreOfMapFourierTransforms</a> (fftw_complex *origMap, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_complex *trFunc, fftw_complex *trFuncCoeffs, fftw_plan planForwardFourier, fftw_plan planForwardFourierRot, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a4e67dc983f98cde3963b0d805f41ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the allocated memory for the Fourier transforms used to find the centre of the map.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a4e67dc983f98cde3963b0d805f41ce30">More...</a><br /></td></tr>
<tr class="separator:a4e67dc983f98cde3963b0d805f41ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec1b87286193d7797b6afa2bed1ea33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">ProSHADE_internal_symmetry::findTranslationBetweenRotatedAndOriginalMap</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *symStr, std::vector&lt; proshade_double &gt; symElem, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_plan planForwardFourierRot, fftw_complex *trFuncCoeffs, fftw_complex *trFunc, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a3ec1b87286193d7797b6afa2bed1ea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a single rotation matrix and procceds to compute the optimal translation between the original map and a map rotated by the supplied rotation matrix.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a3ec1b87286193d7797b6afa2bed1ea33">More...</a><br /></td></tr>
<tr class="separator:a3ec1b87286193d7797b6afa2bed1ea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194544dbfe4daae5fe9300daeb98c779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194544dbfe4daae5fe9300daeb98c779">ProSHADE_internal_symmetry::findPointFromTranslations</a> (<a class="el" href="class_pro_s_h_a_d_e__internal__data_1_1_pro_s_h_a_d_e__data.html">ProSHADE_internal_data::ProSHADE_data</a> *symStr, std::vector&lt; std::vector&lt; proshade_double &gt; &gt; symElems, fftw_complex *origCoeffs, fftw_complex *rotMapComplex, fftw_complex *rotCoeffs, fftw_plan planForwardFourierRot, fftw_complex *trFuncCoeffs, fftw_complex *trFunc, fftw_plan planReverseFourierComb)</td></tr>
<tr class="memdesc:a194544dbfe4daae5fe9300daeb98c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the average of optimal translations for a cyclic point group.  <a href="namespace_pro_s_h_a_d_e__internal__symmetry.html#a194544dbfe4daae5fe9300daeb98c779">More...</a><br /></td></tr>
<tr class="separator:a194544dbfe4daae5fe9300daeb98c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file declares all the functions required for symmetry detection and construction. </p>
<p>This header file declares the <a class="el" href="namespace_pro_s_h_a_d_e__internal__symmetry.html" title="This namespace contains the symmetry detection related code.">ProSHADE_internal_symmetry</a> namespace, which groups all the function required to detect symmetry axes and subsequently to detect symmetry type from the combination of all detected symmetry axes. Currently, this code can detect C, D, T, O and I symmetries with the C and D symmetries having their fold detected as well.</p>
<p>Copyright by Michal Tykac and individual contributors. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3) Neither the name of Michal Tykac nor the names of this code's contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>This software is provided by the copyright holder and contributors "as is" and any express or implied warranties, including, but not limitted to, the implied warranties of merchantibility and fitness for a particular purpose are disclaimed. In no event shall the copyright owner or the contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limitted to, procurement of substitute goods or services, loss of use, data or profits, or business interuption) however caused and on any theory of liability, whether in contract, strict liability or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.</p>
<dl class="section author"><dt>Author</dt><dd>Michal Tykac </dd>
<dd>
Garib N. Murshudov </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.6.6 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>JUL 2022 </dd></dl>

<p class="definition">Definition in file <a class="el" href="_pro_s_h_a_d_e__symmetry_8hpp_source.html">ProSHADE_symmetry.hpp</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fa9be34cc2c3eb9c0decdfb277595ca7.html">proshade</a></li><li class="navelem"><a class="el" href="_pro_s_h_a_d_e__symmetry_8hpp.html">ProSHADE_symmetry.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
