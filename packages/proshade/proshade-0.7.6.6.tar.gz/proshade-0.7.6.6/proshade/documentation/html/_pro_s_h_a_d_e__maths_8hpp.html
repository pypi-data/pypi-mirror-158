<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: src/proshade/ProSHADE_maths.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.6.6 (JUL 2022)</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_pro_s_h_a_d_e__maths_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_maths.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header file declares all the functions required for computing various information from the ProSHADE data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_pro_s_h_a_d_e__misc_8hpp_source.html">ProSHADE_misc.hpp</a>&quot;</code><br />
<code>#include &lt;almostEqual.hpp&gt;</code><br />
</div>
<p><a href="_pro_s_h_a_d_e__maths_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all inputed data for the rotation function angle-axis converted spheres.  <a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_pro_s_h_a_d_e__internal__spheres"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__spheres.html">ProSHADE_internal_spheres</a></td></tr>
<tr class="memdesc:namespace_pro_s_h_a_d_e__internal__spheres"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains the structure and functions required for storing internal map projections onto a set of concentric spheres. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_pro_s_h_a_d_e__internal__maths"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html">ProSHADE_internal_maths</a></td></tr>
<tr class="memdesc:namespace_pro_s_h_a_d_e__internal__maths"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains the internal functions for common mathematical operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa54f5391ab62bf98a331d79d6114c346"><td class="memItemLeft" align="right" valign="top"><a id="aa54f5391ab62bf98a331d79d6114c346"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dgesdd_</b> (char *jobz, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, double *rwork, int *iwork, int *info)</td></tr>
<tr class="separator:aa54f5391ab62bf98a331d79d6114c346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbac6da7eaf965ee286850344c51e7"><td class="memItemLeft" align="right" valign="top"><a id="a0cbbac6da7eaf965ee286850344c51e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zgesdd_</b> (char *jobz, int *m, int *n, std::complex&lt; double &gt; *a, int *lda, double *s, std::complex&lt; double &gt; *u, int *ldu, std::complex&lt; double &gt; *vt, int *ldvt, std::complex&lt; double &gt; *work, int *lwork, double *rwork, int *iwork, int *info)</td></tr>
<tr class="separator:a0cbbac6da7eaf965ee286850344c51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2cf3abcfbf8f70b24b369ee3392b12"><td class="memItemLeft" align="right" valign="top"><a id="aff2cf3abcfbf8f70b24b369ee3392b12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dgeev_</b> (char *jobvl, char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info)</td></tr>
<tr class="separator:aff2cf3abcfbf8f70b24b369ee3392b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254fece06e1cfce122a11ddea4f71970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">ProSHADE_internal_maths::complexMultiplication</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a254fece06e1cfce122a11ddea4f71970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">More...</a><br /></td></tr>
<tr class="separator:a254fece06e1cfce122a11ddea4f71970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">ProSHADE_internal_maths::complexMultiplicationConjug</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers by using the second number's conjugate.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">More...</a><br /></td></tr>
<tr class="separator:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b05344ffead449c29a333a57b404f6"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">ProSHADE_internal_maths::complexMultiplicationRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:ac9b05344ffead449c29a333a57b404f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">More...</a><br /></td></tr>
<tr class="separator:ac9b05344ffead449c29a333a57b404f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59a55f5ed21de90e351005c58a871e"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">ProSHADE_internal_maths::complexMultiplicationConjugRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:abc59a55f5ed21de90e351005c58a871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to conjuggate multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">More...</a><br /></td></tr>
<tr class="separator:abc59a55f5ed21de90e351005c58a871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">ProSHADE_internal_maths::vectorMeanAndSD</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector mean and standard deviation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">More...</a><br /></td></tr>
<tr class="separator:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af185ca14eb5d82fb126092767746e00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">ProSHADE_internal_maths::vectorMedianAndIQR</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:af185ca14eb5d82fb126092767746e00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">More...</a><br /></td></tr>
<tr class="separator:af185ca14eb5d82fb126092767746e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a356017340781739a3bd66c716cfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">ProSHADE_internal_maths::arrayMedianAndIQR</a> (proshade_double *vec, proshade_unsign vecSize, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:aa5a356017340781739a3bd66c716cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get array median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">More...</a><br /></td></tr>
<tr class="separator:aa5a356017340781739a3bd66c716cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894d87e94446db04492b663e54a74bff"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">ProSHADE_internal_maths::pearsonCorrCoeff</a> (proshade_double *valSet1, proshade_double *valSet2, proshade_unsign length)</td></tr>
<tr class="memdesc:a894d87e94446db04492b663e54a74bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing the Pearson's correlation coefficient.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">More...</a><br /></td></tr>
<tr class="separator:a894d87e94446db04492b663e54a74bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e2b40392901a544d6f8786be8a9de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51e2b40392901a544d6f8786be8a9de8">ProSHADE_internal_maths::getLegendreAbscAndWeights</a> (proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_unsign noSteps)</td></tr>
<tr class="memdesc:a51e2b40392901a544d6f8786be8a9de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare abscissas and weights for Gauss-Legendre integration using the Glaser-Liu-Rokhlin method.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51e2b40392901a544d6f8786be8a9de8">More...</a><br /></td></tr>
<tr class="separator:a51e2b40392901a544d6f8786be8a9de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab74b910cda2ee3faa461740a7a432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">ProSHADE_internal_maths::getGLPolyAtZero</a> (proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</td></tr>
<tr class="memdesc:affab74b910cda2ee3faa461740a7a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">More...</a><br /></td></tr>
<tr class="separator:affab74b910cda2ee3faa461740a7a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189a6f44294a59bbae9e8795ce5c8e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3189a6f44294a59bbae9e8795ce5c8e3">ProSHADE_internal_maths::getGLFirstRealRoot</a> (proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a3189a6f44294a59bbae9e8795ce5c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the first root for Legendre polynomials of odd order.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3189a6f44294a59bbae9e8795ce5c8e3">More...</a><br /></td></tr>
<tr class="separator:a3189a6f44294a59bbae9e8795ce5c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15751b9aa49196d1052e7604ef74d01c"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a15751b9aa49196d1052e7604ef74d01c">ProSHADE_internal_maths::evaluateGLPolynomial</a> (proshade_double *series, proshade_double target, proshade_unsign terms)</td></tr>
<tr class="memdesc:a15751b9aa49196d1052e7604ef74d01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates the decomposed Legendre polynomial at a given position.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a15751b9aa49196d1052e7604ef74d01c">More...</a><br /></td></tr>
<tr class="separator:a15751b9aa49196d1052e7604ef74d01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b210054215a4b80387606e94bf674c"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a07b210054215a4b80387606e94bf674c">ProSHADE_internal_maths::advanceGLPolyValue</a> (proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign order, proshade_unsign noSteps)</td></tr>
<tr class="memdesc:a07b210054215a4b80387606e94bf674c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the next value of a Legendre polynomial using the Runge-Kutta method.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a07b210054215a4b80387606e94bf674c">More...</a><br /></td></tr>
<tr class="separator:a07b210054215a4b80387606e94bf674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483d8c9ae8c51ac2bf853075e6b96044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a483d8c9ae8c51ac2bf853075e6b96044">ProSHADE_internal_maths::completeAbscissasAndWeights</a> (proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign noSteps)</td></tr>
<tr class="memdesc:a483d8c9ae8c51ac2bf853075e6b96044"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes the abscissas and weights series from the first roots computed beforehand.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a483d8c9ae8c51ac2bf853075e6b96044">More...</a><br /></td></tr>
<tr class="separator:a483d8c9ae8c51ac2bf853075e6b96044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62133f51851217e3cb28dff2f520d192"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">ProSHADE_internal_maths::gaussLegendreIntegrationReal</a> (proshade_double *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists)</td></tr>
<tr class="memdesc:a62133f51851217e3cb28dff2f520d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">More...</a><br /></td></tr>
<tr class="separator:a62133f51851217e3cb28dff2f520d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4604176a61820f5fcb95e372861c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">ProSHADE_internal_maths::gaussLegendreIntegration</a> (proshade_complex *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a3d4604176a61820f5fcb95e372861c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">More...</a><br /></td></tr>
<tr class="separator:a3d4604176a61820f5fcb95e372861c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98abe6f7fac976a70b608951dbdf993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">ProSHADE_internal_maths::complexMatrixSVDSigmasOnly</a> (proshade_complex **mat, int dim, double *&amp;singularValues)</td></tr>
<tr class="memdesc:ab98abe6f7fac976a70b608951dbdf993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex matrix SVD and return only the sigmas.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">More...</a><br /></td></tr>
<tr class="separator:ab98abe6f7fac976a70b608951dbdf993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d9fe55f079cb37a7446103f6103ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a689d9fe55f079cb37a7446103f6103ba">ProSHADE_internal_maths::realMatrixSVDUandVOnly</a> (proshade_double *mat, int dim, proshade_double *uAndV, bool fail=true)</td></tr>
<tr class="memdesc:a689d9fe55f079cb37a7446103f6103ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the real matrix SVD and return the U and V matrices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a689d9fe55f079cb37a7446103f6103ba">More...</a><br /></td></tr>
<tr class="separator:a689d9fe55f079cb37a7446103f6103ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4df27d692ba004ff73a3f80287b5b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7c4df27d692ba004ff73a3f80287b5b6">ProSHADE_internal_maths::getEulerZYZFromSOFTPosition</a> (proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</td></tr>
<tr class="memdesc:a7c4df27d692ba004ff73a3f80287b5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find Euler angles (ZYZ convention) from index position in the inverse SOFT map.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7c4df27d692ba004ff73a3f80287b5b6">More...</a><br /></td></tr>
<tr class="separator:a7c4df27d692ba004ff73a3f80287b5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3bf506ba66e4536b7cb34138fe61cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6c3bf506ba66e4536b7cb34138fe61cd">ProSHADE_internal_maths::getSOFTPositionFromEulerZYZ</a> (proshade_signed band, proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *x, proshade_double *y, proshade_double *z)</td></tr>
<tr class="memdesc:a6c3bf506ba66e4536b7cb34138fe61cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the index position in the inverse SOFT map from given Euler angles (ZYZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6c3bf506ba66e4536b7cb34138fe61cd">More...</a><br /></td></tr>
<tr class="separator:a6c3bf506ba66e4536b7cb34138fe61cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa641924ffebe607a335350a07a14ce11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa641924ffebe607a335350a07a14ce11">ProSHADE_internal_maths::getRotationMatrixFromEulerZYZAngles</a> (proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</td></tr>
<tr class="memdesc:aa641924ffebe607a335350a07a14ce11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the rotation matrix from Euler angles (ZYZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa641924ffebe607a335350a07a14ce11">More...</a><br /></td></tr>
<tr class="separator:aa641924ffebe607a335350a07a14ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550d6831b0d3e28f3eed60902705450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4550d6831b0d3e28f3eed60902705450">ProSHADE_internal_maths::getRotationMatrixFromEulerZYZAngles</a> (proshade_single eulerAlpha, proshade_single eulerBeta, proshade_single eulerGamma, proshade_single *matrix)</td></tr>
<tr class="memdesc:a4550d6831b0d3e28f3eed60902705450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the rotation matrix from Euler angles (ZYZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4550d6831b0d3e28f3eed60902705450">More...</a><br /></td></tr>
<tr class="separator:a4550d6831b0d3e28f3eed60902705450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5409074bece14a244fad191524a687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aad5409074bece14a244fad191524a687">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> (proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang, proshade_signed verbose=1)</td></tr>
<tr class="memdesc:aad5409074bece14a244fad191524a687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aad5409074bece14a244fad191524a687">More...</a><br /></td></tr>
<tr class="separator:aad5409074bece14a244fad191524a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42a4efcef6dffaf047acde57acea99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aec42a4efcef6dffaf047acde57acea99">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> (std::vector&lt; proshade_double &gt; *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang, proshade_signed verbose=1)</td></tr>
<tr class="memdesc:aec42a4efcef6dffaf047acde57acea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aec42a4efcef6dffaf047acde57acea99">More...</a><br /></td></tr>
<tr class="separator:aec42a4efcef6dffaf047acde57acea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eafef902a49cc0816a2ed675c14a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> (proshade_double *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</td></tr>
<tr class="memdesc:a39eafef902a49cc0816a2ed675c14a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the axis-angle representation to the rotation matrix representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">More...</a><br /></td></tr>
<tr class="separator:a39eafef902a49cc0816a2ed675c14a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860239f5ba95153f2b12d40a5742936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a0860239f5ba95153f2b12d40a5742936">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> (proshade_single *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</td></tr>
<tr class="memdesc:a0860239f5ba95153f2b12d40a5742936"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the axis-angle representation to the rotation matrix representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a0860239f5ba95153f2b12d40a5742936">More...</a><br /></td></tr>
<tr class="separator:a0860239f5ba95153f2b12d40a5742936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc0151f1586561eaf298d6697cae7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aedc0151f1586561eaf298d6697cae7c0">ProSHADE_internal_maths::getEulerZYZFromRotMatrix</a> (proshade_double *rotMat, proshade_double *eA, proshade_double *eB, proshade_double *eG)</td></tr>
<tr class="memdesc:aedc0151f1586561eaf298d6697cae7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the Euler ZYZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aedc0151f1586561eaf298d6697cae7c0">More...</a><br /></td></tr>
<tr class="separator:aedc0151f1586561eaf298d6697cae7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ebdef9456bc4d6efa7dc0e69d89cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a82ebdef9456bc4d6efa7dc0e69d89cf6">ProSHADE_internal_maths::getEulerZYZFromAngleAxis</a> (proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *eA, proshade_double *eB, proshade_double *eG)</td></tr>
<tr class="memdesc:a82ebdef9456bc4d6efa7dc0e69d89cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts angle-axis representation to the Euler ZYZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a82ebdef9456bc4d6efa7dc0e69d89cf6">More...</a><br /></td></tr>
<tr class="separator:a82ebdef9456bc4d6efa7dc0e69d89cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a10bbc3e6e75c26cfbe90664dd2a7d151">ProSHADE_internal_maths::multiplyTwoSquareMatrices</a> (proshade_double *A, proshade_double *B, proshade_double *res, proshade_unsign dim=3)</td></tr>
<tr class="memdesc:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a10bbc3e6e75c26cfbe90664dd2a7d151">More...</a><br /></td></tr>
<tr class="separator:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359dd366cdd986f5ad155bff8235a8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_signed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">ProSHADE_internal_maths::primeFactorsDecomp</a> (proshade_signed number)</td></tr>
<tr class="memdesc:a6359dd366cdd986f5ad155bff8235a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find prime factors of an integer.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">More...</a><br /></td></tr>
<tr class="separator:a6359dd366cdd986f5ad155bff8235a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01087ea3e0db56758d1771618e2e4a45"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">ProSHADE_internal_maths::normalDistributionValue</a> (proshade_double mean, proshade_double standardDev, proshade_double value)</td></tr>
<tr class="memdesc:a01087ea3e0db56758d1771618e2e4a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to the heiht of normal distribution given by mean and standard deviation for a given value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">More...</a><br /></td></tr>
<tr class="separator:a01087ea3e0db56758d1771618e2e4a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a2ac3b534f974de25b092e9d48d9f7dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">More...</a><br /></td></tr>
<tr class="separator:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">ProSHADE_internal_maths::computeDotProduct</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">More...</a><br /></td></tr>
<tr class="separator:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61807efeb86ea021f3d17ac531911c3c"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">ProSHADE_internal_maths::computeCrossProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a61807efeb86ea021f3d17ac531911c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector cross product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">More...</a><br /></td></tr>
<tr class="separator:a61807efeb86ea021f3d17ac531911c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbee3728be168eb54099ddb9bc0689a"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2bbee3728be168eb54099ddb9bc0689a">ProSHADE_internal_maths::computeCrossProduct</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a2bbee3728be168eb54099ddb9bc0689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector cross product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2bbee3728be168eb54099ddb9bc0689a">More...</a><br /></td></tr>
<tr class="separator:a2bbee3728be168eb54099ddb9bc0689a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a> (proshade_double *mat1, proshade_double *mat2)</td></tr>
<tr class="memdesc:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">More...</a><br /></td></tr>
<tr class="separator:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c7716f6ab682e8548ab77efcdc444"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> (proshade_double *mat, proshade_double x, proshade_double y, proshade_double z)</td></tr>
<tr class="memdesc:a2f9c7716f6ab682e8548ab77efcdc444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix to 3x1 vector multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">More...</a><br /></td></tr>
<tr class="separator:a2f9c7716f6ab682e8548ab77efcdc444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c83ae1b2f9783ad8df6ff6dfbbc3b9d"><td class="memItemLeft" align="right" valign="top">proshade_single *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6c83ae1b2f9783ad8df6ff6dfbbc3b9d">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> (proshade_single *mat, proshade_single x, proshade_single y, proshade_single z)</td></tr>
<tr class="memdesc:a6c83ae1b2f9783ad8df6ff6dfbbc3b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix to 3x1 vector multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6c83ae1b2f9783ad8df6ff6dfbbc3b9d">More...</a><br /></td></tr>
<tr class="separator:a6c83ae1b2f9783ad8df6ff6dfbbc3b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ac617b105e1ca1729800c5f290b567"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ac617b105e1ca1729800c5f290b567">ProSHADE_internal_maths::compute3x3MatrixInverse</a> (proshade_double *mat)</td></tr>
<tr class="memdesc:a83ac617b105e1ca1729800c5f290b567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix inverse.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ac617b105e1ca1729800c5f290b567">More...</a><br /></td></tr>
<tr class="separator:a83ac617b105e1ca1729800c5f290b567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e18da715a7b9e6d84f6eda66b40e4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4e18da715a7b9e6d84f6eda66b40e4e5">ProSHADE_internal_maths::transpose3x3MatrixInPlace</a> (proshade_single *mat)</td></tr>
<tr class="memdesc:a4e18da715a7b9e6d84f6eda66b40e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes 3x3 matrix in place.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4e18da715a7b9e6d84f6eda66b40e4e5">More...</a><br /></td></tr>
<tr class="separator:a4e18da715a7b9e6d84f6eda66b40e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c48ee69a642f279354789f09b02296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac6c48ee69a642f279354789f09b02296">ProSHADE_internal_maths::transpose3x3MatrixInPlace</a> (proshade_double *mat)</td></tr>
<tr class="memdesc:ac6c48ee69a642f279354789f09b02296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes 3x3 matrix in place.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac6c48ee69a642f279354789f09b02296">More...</a><br /></td></tr>
<tr class="separator:ac6c48ee69a642f279354789f09b02296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65abe8c99adbd99419b9c65d25a3b2"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5a65abe8c99adbd99419b9c65d25a3b2">ProSHADE_internal_maths::build3x3MatrixFromDiag</a> (proshade_double *diag)</td></tr>
<tr class="memdesc:a5a65abe8c99adbd99419b9c65d25a3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for building a 3x3 matrix from diagonal (and assuming zero padding).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5a65abe8c99adbd99419b9c65d25a3b2">More...</a><br /></td></tr>
<tr class="separator:a5a65abe8c99adbd99419b9c65d25a3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a5f7b87baedbe1cd37ad588d3fca92"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a12a5f7b87baedbe1cd37ad588d3fca92">ProSHADE_internal_maths::build3x3MatrixFromXYZRotations</a> (proshade_double xRot, proshade_double yRot, proshade_double zRot)</td></tr>
<tr class="memdesc:a12a5f7b87baedbe1cd37ad588d3fca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for building a 3x3 rotation matrix from the x, y and z rotations in degrees.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a12a5f7b87baedbe1cd37ad588d3fca92">More...</a><br /></td></tr>
<tr class="separator:a12a5f7b87baedbe1cd37ad588d3fca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b17617f8b3c42c5199948828cd1a57b"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a2b17617f8b3c42c5199948828cd1a57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of rotation matrix rotating one vector onto the other.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">More...</a><br /></td></tr>
<tr class="separator:a2b17617f8b3c42c5199948828cd1a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044f4684d6d52d1242225e3969a4813b"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a044f4684d6d52d1242225e3969a4813b">ProSHADE_internal_maths::compute3x3MoorePenrosePseudoInverseOfIMinusMat</a> (std::vector&lt; proshade_double &gt; *rMat, proshade_signed verbose)</td></tr>
<tr class="memdesc:a044f4684d6d52d1242225e3969a4813b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the Moore-Penrose pseudo-inverse of equation I - input matrix.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a044f4684d6d52d1242225e3969a4813b">More...</a><br /></td></tr>
<tr class="separator:a044f4684d6d52d1242225e3969a4813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double dot1, proshade_double dot2)</td></tr>
<tr class="memdesc:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given two dot products to two other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">More...</a><br /></td></tr>
<tr class="separator:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f376bb341b192fff008b9b4ef5c603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double x3, proshade_double y3, proshade_double z3, proshade_double dot1, proshade_double dot2, proshade_double dot3)</td></tr>
<tr class="memdesc:ae9f376bb341b192fff008b9b4ef5c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given three dot products to three other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">More...</a><br /></td></tr>
<tr class="separator:ae9f376bb341b192fff008b9b4ef5c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18222a942e5fff8eecd15f1235c609e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">ProSHADE_internal_maths::multiplyGroupElementMatrices</a> (std::vector&lt; proshade_double &gt; *el1, std::vector&lt; proshade_double &gt; *el2)</td></tr>
<tr class="memdesc:a18222a942e5fff8eecd15f1235c609e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes matrix multiplication using the ProSHADE group element matrix format as input and output.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">More...</a><br /></td></tr>
<tr class="separator:a18222a942e5fff8eecd15f1235c609e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">ProSHADE_internal_maths::rotationMatrixSimilarity</a> (std::vector&lt; proshade_double &gt; *mat1, std::vector&lt; proshade_double &gt; *mat2, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a4348a7a36275c9cea20b5c27093c9b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares the distance between two rotation matrices and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">More...</a><br /></td></tr>
<tr class="separator:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564e6272f205c6c44f734c6200ca520c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a564e6272f205c6c44f734c6200ca520c">ProSHADE_internal_maths::rotationMatrixSimilarity</a> (proshade_double *mat1, proshade_double *mat2, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a564e6272f205c6c44f734c6200ca520c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares the distance between two rotation matrices and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a564e6272f205c6c44f734c6200ca520c">More...</a><br /></td></tr>
<tr class="separator:a564e6272f205c6c44f734c6200ca520c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b74d6e9732d99ea62a5212bac9527f"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#af7b74d6e9732d99ea62a5212bac9527f">ProSHADE_internal_maths::rotationMatrixSimilarityValue</a> (std::vector&lt; proshade_double &gt; *mat1, std::vector&lt; proshade_double &gt; *mat2)</td></tr>
<tr class="memdesc:af7b74d6e9732d99ea62a5212bac9527f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the distance between two rotation matrices and returns it.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#af7b74d6e9732d99ea62a5212bac9527f">More...</a><br /></td></tr>
<tr class="separator:af7b74d6e9732d99ea62a5212bac9527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096ed4f79375598802116f2473dd218c"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a096ed4f79375598802116f2473dd218c">ProSHADE_internal_maths::rotationMatrixSimilarityValue</a> (proshade_double *mat1, proshade_double *mat2)</td></tr>
<tr class="memdesc:a096ed4f79375598802116f2473dd218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the distance between two rotation matrices and returns it.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a096ed4f79375598802116f2473dd218c">More...</a><br /></td></tr>
<tr class="separator:a096ed4f79375598802116f2473dd218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a2b2f67cba1eea57f19fdaf062db74fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">More...</a><br /></td></tr>
<tr class="separator:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e789452e327bb07a53c5358f4d3eb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">ProSHADE_internal_maths::vectorOrientationSimilaritySameDirection</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a79e789452e327bb07a53c5358f4d3eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">More...</a><br /></td></tr>
<tr class="separator:a79e789452e327bb07a53c5358f4d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51486f6276c28c1b503f19c36007b9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">ProSHADE_internal_maths::optimiseAxisBiCubicInterpolation</a> (proshade_double *bestLattitude, proshade_double *bestLongitude, proshade_double *bestSum, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun, proshade_double step=0.05)</td></tr>
<tr class="memdesc:a51486f6276c28c1b503f19c36007b9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides axis optimisation given starting lattitude and longitude indices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">More...</a><br /></td></tr>
<tr class="separator:a51486f6276c28c1b503f19c36007b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">More...</a><br /></td></tr>
<tr class="separator:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c2321ffcef5079634493d9bf65749b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a73c2321ffcef5079634493d9bf65749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">More...</a><br /></td></tr>
<tr class="separator:a73c2321ffcef5079634493d9bf65749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a3f12eb80331377a36ee6b3a4f8e65147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">More...</a><br /></td></tr>
<tr class="separator:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b355465dd2244b51e579dcb8669b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac3b355465dd2244b51e579dcb8669b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">More...</a><br /></td></tr>
<tr class="separator:ac3b355465dd2244b51e579dcb8669b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2380a3710f7dbe672519c3adda30f7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance=0.1, bool improve=false)</td></tr>
<tr class="memdesc:a2380a3710f7dbe672519c3adda30f7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">More...</a><br /></td></tr>
<tr class="separator:a2380a3710f7dbe672519c3adda30f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f093fbdd34498d27a4d8998b620c91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">ProSHADE_internal_maths::isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double X, proshade_double Y, proshade_double Z, proshade_double fold, proshade_double tolerance)</td></tr>
<tr class="memdesc:a49f093fbdd34498d27a4d8998b620c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">More...</a><br /></td></tr>
<tr class="separator:a49f093fbdd34498d27a4d8998b620c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f74449c947cbf139f9700bc9f2e7119"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f74449c947cbf139f9700bc9f2e7119">ProSHADE_internal_maths::whichAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance)</td></tr>
<tr class="memdesc:a5f74449c947cbf139f9700bc9f2e7119"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected and returns the position of match or -1.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f74449c947cbf139f9700bc9f2e7119">More...</a><br /></td></tr>
<tr class="separator:a5f74449c947cbf139f9700bc9f2e7119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99cf5a693118bf979c235d9e7ae05d4"><td class="memItemLeft" align="right" valign="top">proshade_signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa99cf5a693118bf979c235d9e7ae05d4">ProSHADE_internal_maths::whichAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double X, proshade_double Y, proshade_double Z, proshade_double fold, proshade_double tolerance)</td></tr>
<tr class="memdesc:aa99cf5a693118bf979c235d9e7ae05d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected and returns the position of match or -1.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa99cf5a693118bf979c235d9e7ae05d4">More...</a><br /></td></tr>
<tr class="separator:aa99cf5a693118bf979c235d9e7ae05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2454c19169bb38d616e52b99f1dc4495"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_unsign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">ProSHADE_internal_maths::findAllPrimes</a> (proshade_unsign upTo)</td></tr>
<tr class="memdesc:a2454c19169bb38d616e52b99f1dc4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all prime numbers up to the supplied limit.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">More...</a><br /></td></tr>
<tr class="separator:a2454c19169bb38d616e52b99f1dc4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdd194fd4d4a4415d0bb8711e300add"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#accdd194fd4d4a4415d0bb8711e300add">ProSHADE_internal_maths::isPrime</a> (proshade_unsign toCheck)</td></tr>
<tr class="memdesc:accdd194fd4d4a4415d0bb8711e300add"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check is the supplied number is prime or not.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#accdd194fd4d4a4415d0bb8711e300add">More...</a><br /></td></tr>
<tr class="separator:accdd194fd4d4a4415d0bb8711e300add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30fc4ec4f4239e4860270955a28fdcc"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ad30fc4ec4f4239e4860270955a28fdcc">ProSHADE_internal_maths::computeGaussian</a> (proshade_double val, proshade_double sigma)</td></tr>
<tr class="memdesc:ad30fc4ec4f4239e4860270955a28fdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes a Gaussian (normal) distribution value given distance from mean and sigma.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ad30fc4ec4f4239e4860270955a28fdcc">More...</a><br /></td></tr>
<tr class="separator:ad30fc4ec4f4239e4860270955a28fdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ad1d4fcd0902147fc6f87e09c08ca9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ad1d4fcd0902147fc6f87e09c08ca9">ProSHADE_internal_maths::smoothen1D</a> (proshade_double step, proshade_signed windowSize, proshade_double sigma, std::vector&lt; proshade_double &gt; data, proshade_signed decRound=2)</td></tr>
<tr class="memdesc:a83ad1d4fcd0902147fc6f87e09c08ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a 1D vector and computes smoothened version based on the parameters.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ad1d4fcd0902147fc6f87e09c08ca9">More...</a><br /></td></tr>
<tr class="separator:a83ad1d4fcd0902147fc6f87e09c08ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51be603bcedf202a40a490aa3fc8d45a"><td class="memItemLeft" align="right" valign="top">proshade_single&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51be603bcedf202a40a490aa3fc8d45a">ProSHADE_internal_maths::getResolutionOfReflection</a> (proshade_single h, proshade_single k, proshade_single l, proshade_single xDim, proshade_single yDim, proshade_single zDim)</td></tr>
<tr class="memdesc:a51be603bcedf202a40a490aa3fc8d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the resolution of a particular reflection.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51be603bcedf202a40a490aa3fc8d45a">More...</a><br /></td></tr>
<tr class="separator:a51be603bcedf202a40a490aa3fc8d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db61d55ecc0496454c2985d4e21d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac8db61d55ecc0496454c2985d4e21d8b">ProSHADE_internal_maths::binReciprocalSpaceReflections</a> (proshade_unsign xInds, proshade_unsign yInds, proshade_unsign zInds, proshade_single xSize, proshade_single ySize, proshade_single zSize, proshade_signed *noBin, proshade_signed *&amp;binIndexing, std::vector&lt; proshade_single &gt; *&amp;resArray)</td></tr>
<tr class="memdesc:ac8db61d55ecc0496454c2985d4e21d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does binning of the reciprocal space reflections.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac8db61d55ecc0496454c2985d4e21d8b">More...</a><br /></td></tr>
<tr class="separator:ac8db61d55ecc0496454c2985d4e21d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2c10e26fe26ca95c849d8570a8ec2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8d2c10e26fe26ca95c849d8570a8ec2a">ProSHADE_internal_maths::cutIndicesToResolution</a> (proshade_signed xInds, proshade_signed yInds, proshade_signed zInds, proshade_single resolution, proshade_signed *binIndexing, std::vector&lt; proshade_single &gt; *resArray, proshade_signed *cutXDim, proshade_signed *cutYDim, proshade_signed *cutZDim, proshade_signed *&amp;cutBinIndices, proshade_signed *&amp;noBins)</td></tr>
<tr class="memdesc:a8d2c10e26fe26ca95c849d8570a8ec2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function cuts the bin assignment array into a smaller array containing all bins up to a given resolution.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8d2c10e26fe26ca95c849d8570a8ec2a">More...</a><br /></td></tr>
<tr class="separator:a8d2c10e26fe26ca95c849d8570a8ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24635e94df5eb2a7ee792e02ac49a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac24635e94df5eb2a7ee792e02ac49a84">ProSHADE_internal_maths::cutArrayToResolution</a> (proshade_signed xInds, proshade_signed yInds, proshade_signed zInds, proshade_signed noBins, fftw_complex *inputMap, fftw_complex *&amp;cutMap)</td></tr>
<tr class="memdesc:ac24635e94df5eb2a7ee792e02ac49a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function re-sizes data array to contain only values up to a particular resolution bin.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac24635e94df5eb2a7ee792e02ac49a84">More...</a><br /></td></tr>
<tr class="separator:ac24635e94df5eb2a7ee792e02ac49a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a8864f70989536606fb8cc5363aead"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa9a8864f70989536606fb8cc5363aead">ProSHADE_internal_maths::computeFSC</a> (fftw_complex *fCoeffs1, fftw_complex *fCoeffs2, proshade_signed xInds, proshade_signed yInds, proshade_signed zInds, proshade_signed noBins, proshade_signed *binIndexing, proshade_double **&amp;binData, proshade_signed *&amp;binCounts, proshade_double *&amp;fscByBin, bool averageByBinSize=false)</td></tr>
<tr class="memdesc:aa9a8864f70989536606fb8cc5363aead"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the FSC.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa9a8864f70989536606fb8cc5363aead">More...</a><br /></td></tr>
<tr class="separator:aa9a8864f70989536606fb8cc5363aead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4915884de2c0c846d74baf77003ca29c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4915884de2c0c846d74baf77003ca29c">ProSHADE_internal_maths::computeFSCWeightByBin</a> (proshade_double *&amp;weights1, proshade_double *&amp;weights2, proshade_signed *binIndexing, proshade_double *fscByBin, proshade_signed noBins, proshade_signed xDim, proshade_signed yDim, proshade_signed zDim)</td></tr>
<tr class="memdesc:a4915884de2c0c846d74baf77003ca29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the weights for each reflection using its bin belonging.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4915884de2c0c846d74baf77003ca29c">More...</a><br /></td></tr>
<tr class="separator:a4915884de2c0c846d74baf77003ca29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8ecf33b4e65b2404ce064b054845b1"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4d8ecf33b4e65b2404ce064b054845b1">ProSHADE_internal_maths::computeTheFValue</a> (proshade_complex *fCoeffs, proshade_double *weights, proshade_signed xDim, proshade_signed yDim, proshade_signed zDim)</td></tr>
<tr class="memdesc:a4d8ecf33b4e65b2404ce064b054845b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the real part of the sum of all coefficients except where the weight is less than -2.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4d8ecf33b4e65b2404ce064b054845b1">More...</a><br /></td></tr>
<tr class="separator:a4d8ecf33b4e65b2404ce064b054845b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf8a79d316806c1140c6cd7a9b49ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39cf8a79d316806c1140c6cd7a9b49ca">ProSHADE_internal_maths::computeTrFunDerivatives</a> (proshade_complex *fCoeffs, proshade_double *weights1, proshade_double *weights2, proshade_signed xDim, proshade_signed yDim, proshade_signed zDim, proshade_double *&amp;firstDers, proshade_double *&amp;secondDers)</td></tr>
<tr class="memdesc:a39cf8a79d316806c1140c6cd7a9b49ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the first and second derivatives of the translation function at coefficient [0,0,0].  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39cf8a79d316806c1140c6cd7a9b49ca">More...</a><br /></td></tr>
<tr class="separator:a39cf8a79d316806c1140c6cd7a9b49ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa32a45083a0154c5f0b039bae9ab39"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7fa32a45083a0154c5f0b039bae9ab39">ProSHADE_internal_maths::computeTrFunStep</a> (proshade_double *firstDers, proshade_double *secondDers)</td></tr>
<tr class="memdesc:a7fa32a45083a0154c5f0b039bae9ab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the step sizes for translation function optimisation from the first and second derivatives.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7fa32a45083a0154c5f0b039bae9ab39">More...</a><br /></td></tr>
<tr class="separator:a7fa32a45083a0154c5f0b039bae9ab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02121573c2176b879404bad104b33e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_signed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ab02121573c2176b879404bad104b33e4">ProSHADE_internal_maths::findPeaks1D</a> (std::vector&lt; proshade_double &gt; data)</td></tr>
<tr class="memdesc:ab02121573c2176b879404bad104b33e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply finds all the peaks in a 1D data array.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ab02121573c2176b879404bad104b33e4">More...</a><br /></td></tr>
<tr class="separator:ab02121573c2176b879404bad104b33e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf5cec480f2fa3deae1ba709168f8ff"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#adcf5cec480f2fa3deae1ba709168f8ff">ProSHADE_internal_maths::findTopGroupSmooth</a> (std::vector&lt; proshade_double * &gt; *CSym, size_t peakPos, proshade_double step, proshade_double sigma, proshade_signed windowSize, proshade_double maxLim=1.0)</td></tr>
<tr class="memdesc:adcf5cec480f2fa3deae1ba709168f8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds a subgroup of axes with distinctly higher correlation value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#adcf5cec480f2fa3deae1ba709168f8ff">More...</a><br /></td></tr>
<tr class="separator:adcf5cec480f2fa3deae1ba709168f8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8244eafa79d0def2d6b7678d32c5e2ee"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8244eafa79d0def2d6b7678d32c5e2ee">ProSHADE_internal_maths::findTopGroupSmooth</a> (std::vector&lt; std::vector&lt; proshade_double &gt; &gt; *CSym, size_t peakPos, proshade_double step, proshade_double sigma, proshade_signed windowSize, proshade_double maxLim=1.0)</td></tr>
<tr class="memdesc:a8244eafa79d0def2d6b7678d32c5e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds a subgroup of axes with distinctly higher correlation value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8244eafa79d0def2d6b7678d32c5e2ee">More...</a><br /></td></tr>
<tr class="separator:a8244eafa79d0def2d6b7678d32c5e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ba4ba55d58078eeea8b70311e4ab49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a64ba4ba55d58078eeea8b70311e4ab49">ProSHADE_internal_maths::combineFourierForTranslation</a> (fftw_complex *tmpOut1, fftw_complex *tmpOut2, fftw_complex *&amp;resOut, proshade_unsign xD, proshade_unsign yD, proshade_unsign zD)</td></tr>
<tr class="memdesc:a64ba4ba55d58078eeea8b70311e4ab49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function combines Fourier coefficients of two structures in a way, so that inverse Fourier of the combination will be the translation function.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a64ba4ba55d58078eeea8b70311e4ab49">More...</a><br /></td></tr>
<tr class="separator:a64ba4ba55d58078eeea8b70311e4ab49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caf87603d759cb0de1b0bd834ae8f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7caf87603d759cb0de1b0bd834ae8f6d">ProSHADE_internal_maths::findHighestValueInMap</a> (fftw_complex *resIn, proshade_unsign xD, proshade_unsign yD, proshade_unsign zD, proshade_double *trsX, proshade_double *trsY, proshade_double *trsZ, proshade_double *mapPeak)</td></tr>
<tr class="memdesc:a7caf87603d759cb0de1b0bd834ae8f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply finds the highest value in fftw_complex map and returns its position and value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7caf87603d759cb0de1b0bd834ae8f6d">More...</a><br /></td></tr>
<tr class="separator:a7caf87603d759cb0de1b0bd834ae8f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file declares all the functions required for computing various information from the ProSHADE data. </p>
<p>This header file declares the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html" title="This namespace contains the internal functions for common mathematical operations.">ProSHADE_internal_maths</a> namespace, which groups all the functions required to computed various information from the specific ProSHADE data and its organisation. The functionalities available here include complex number computations, rotation representation conversions as well as Gauss-Legendre integration.</p>
<p>Copyright by Michal Tykac and individual contributors. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3) Neither the name of Michal Tykac nor the names of this code's contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>This software is provided by the copyright holder and contributors "as is" and any express or implied warranties, including, but not limitted to, the implied warranties of merchantibility and fitness for a particular purpose are disclaimed. In no event shall the copyright owner or the contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limitted to, procurement of substitute goods or services, loss of use, data or profits, or business interuption) however caused and on any theory of liability, whether in contract, strict liability or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.</p>
<dl class="section author"><dt>Author</dt><dd>Michal Tykac </dd>
<dd>
Garib N. Murshudov </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.6.6 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>JUL 2022 </dd></dl>

<p class="definition">Definition in file <a class="el" href="_pro_s_h_a_d_e__maths_8hpp_source.html">ProSHADE_maths.hpp</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fa9be34cc2c3eb9c0decdfb277595ca7.html">proshade</a></li><li class="navelem"><a class="el" href="_pro_s_h_a_d_e__maths_8hpp.html">ProSHADE_maths.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
